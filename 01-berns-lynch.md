## Нижняя оценка на число ячеек памяти для протокола взаимного исключения

### Теорема (Бернс, Линч)

> Любой протокол взаимного исключения для `n` потоков, построенный только на атомарных чтениях и записях, использует по крайней мере `n` ячеек памяти.

#### Доказательство теоремы

Предположим, работают `n` потоков и есть протокол, который:  
* гарантирует взаимное исключение (mutual exclusion, ME);
* гарантирует свободу от взаимной блокировки (deadlock freedom, DLF);

Докажем, что такого протокола не существует.

##### Лемма

> Для взаимного исключения каждый поток должен сделать запись хотя бы в один регистр.

##### Доказательство леммы:

Предположим, поток заходит в критическую секцию, но не выполняет записи в память. Тогда другие потоки не увидят никаких следов (т.е. записей в память); для них исполнение будет неотличимо от исполнения, где первого потока вообще не было, а значит по гарантии прогресса (в данном случае, DLF) кто-нибудь из них должен зайти в критическую секцию._

##### Доказательство теоремы:

Даны потоки `T_1`, `T_2`, …, `T_[n+1]` и ячейки памяти `X_1`, `X_2`, …, `X_n`. По лемме каждый поток что-то пишет хотя бы в одну из ячеек памяти. Рассмотрим такую конфигурацию, что `T_1`, `T_2`, …, `T_n` остановлены перед своими первыми записями в `X_1`, `X_2`, …, `X_n` соответственно (без потери общности), причем ячейки `X_1`, `X_2`, …, `X_n` содержат начальные значения. Пусть поток `T_[n+1]` проходит в критическую секцию. Далее `T_1` делает свою запись в `X_1`, затем `T_2` делает свою запись в `X_2`, …, затем `T_n` делает свою запись в `X_n`. Таким образом, стерты все следы существования потока `T_[n+1]`. Тогда (по DLF) один из потоков `T_1`, `T_2`, …, `T_n` проходит в критическую секцию. Нарушается ME.

Докажем, что описанную конфигурацию всегда можно получить, индукцией по числу потоков.

_Утверждение._ Пусть `1⩽k⩽n`.  Тогда существует конфигурация, когда `T_1`, `T_2`, …, `T_k` остановлены перед своими первыми записями в разные `k` ячеек памяти, причем все ячейки памяти содержат начальные значения.

База при `k=1` очевидна.

Пусть теперь `k>1`. По предположению индукции возможно получить конфигурацию, когда `T_1`, `T_2`, …, `T_k` пишут в разные `k` ячеек памяти. Обозначим через `ConfigureThreads()` последовательность операций, приводящую к такой конфигурации. Из `k` потоков в `k` ячеек памяти из `n` возможных существует `C[n,k]` различных отображений. Тогда пусть потоки выполняют `ConfigureThreads() → ConfigureThreads() → … → ConfigureThreads()` всего `C[n,k]+1` раз. По принципу Дирихле найдется такие две `ConfigureThreads()`, которые делают одно и то же соответствие между `T_1`, `T_2`, …, `T_k` и `k` ячейками памяти. Без ограничения общности, это первый и последний вызов `ConfigureThreads()`, а запись осуществлена в ячейки памяти `X_1`, `X_2`, …, `X_k` соответственно.

Рассмотрим найденное выполнение операций `ConfigureThreads() → …`. Остановим потоки в рассмотренной выше конфигурации на первой итерации. Далее запустим `T_[k+1]`. По лемме он пишет что-то в какую-то из ячеек `X_[k+1]`, …, `X_n`. Остановим его перед первой записью в какую-то из этих ячеек --- возможно, он при этом что-то записал в какие-то из ячеек `X_1`, …, `X_k`. Далее запускаем наши `ConfigureThreads()` и останавливаем потоки перед своими первыми записями в `X_1`, …, `X_k` на последней итерации. По построению ячейки `X_[k+1]`, …, `X_n` содержат начальные значения. Таким образом, потоки `T_1`, …, `T_k`, `T_[k+1]` остановлены перед своими первыми записями в разные `k+1` ячеек памяти. _Утверждение доказано._

_Значит, искомая конфигурация существует для `k=n`, что и доказывает теорему в общем случае._

#### Замечания

* Каждый метод `lock()` не обязан требовать обращения ко всем `n` ячейкам памяти. Например, в турнирном дереве мьютексов один вызов обращается к `O(log(n))` ячейкам.  
* Для построения противоречия мы не использовали никаких предположений о разрядности ячеек памяти.  
* Доказательство работает даже для случая недетерминированного исполнения.  
* Доказательство не работает, если используется операция `exchange()` или другая RMW-операция: с их помощью можно атомарно менять значение в ячейке памяти и читать старое значение, на основании которого делать выводы о наличии других потоков.  
* Каждый `ConfigureThreads()` для `k` потоков построен с помощью `C[n,k-1]+1` операций `ConfigureThreads()` для `k-1` потоков. Таким образом, для построения «плохого исполнения» в случае `n` потоков используется экспоненциальное число шагов (сумма биномиальных коэффициентов).
