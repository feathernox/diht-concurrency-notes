## Нижняя оценка на число ячеек памяти для протокола взаимного исключения

### Теорема (Бернс, Линч)

> Любой протокол взаимного исключения для `n` потоков, построенный только на атомарных чтениях и записях, использует по крайней мере `n` ячеек памяти.

#### Доказательство

Предположим, работают `n` потоков и есть протокол, который:  
* гарантирует взаимное исключение (ME);
* гарантирует свободу от взаимной блокировки (DLF);

Докажем, что такого протокола не существует.

##### Лемма

> Любой протокол взаимного исключения для `n` потоков, построенный только на атомарных чтениях и записях, использует по крайней мере `n` ячеек памяти.

##### Для `n=2`

Даны потоки `T_1`, `T_2` и ячейка памяти `X_1`. Рассмотрим два случая:  
1. пусть поток `T_1` ничего не пишет и заходит в критическую секцию (СВБ). Тогда пришедший поток `T_2` увидет мьютекс в исходном состоянии и также пройдет в критическую секцию. Нарушается ВИ;  
1. пусть поток `T_1` пишет что-то в ячейку `X_1`. Тогда пусть планировщик останавливает выполнение потока `T_1` перед его первой записью в `X_1`. После этого пришедший поток `T_2` проходит в критическую секцию (СВБ). Тогда проснувшийся поток `T_1` первым действием уничтожит все следы существования потока `T_2`, записав свое значение в `X_1`. Таким образом, (по СВБ) он проходит в критическую секцию. Нарушается ВИ.

_В обоих случаях получено противоречие, следовательно, для `n=2` теорема доказана._

##### Для произвольного `n`

Даны потоки `T_1`, `T_2`, …, `T_[n+1]` и ячейки памяти `X_1`, `X_2`, …, `X_n`. Ясно, что каждый поток что-то пишет хотя бы в одну из ячеек памяти. Рассмотрим такую конфигурацию, что `T_1`, `T_2`, …, `T_n` остановлены перед своими первыми записями в `X_1`, `X_2`, …, `X_n` соответственно (без потери общности), причем ячейки `X_1`, `X_2`, …, `X_n` содержат начальные значения. Пусть поток `T_[n+1]` проходит в критическую секцию. Далее `T_1` делает свою запись в `X_1`, затем `T_2` делает свою запись в `X_2`, …, затем `T_n` делает свою запись в `X_n`. Таким образом, стерты все следы существования потока `T_[n+1]`. Тогда (по СВБ) один из потоков `T_1`, `T_2`, …, `T_n` проходит в критическую секцию. Нарушеается ВИ.

Докажем, что описанную конфигурацию всегда можно получить, индукцией по числу потоков.

_Утверждение._ Пусть `1⩽k⩽n`.  Тогда существует конфигурация, когда `T_1`, `T_2`, …, `T_k` остановлены перед своими первыми записями в разные `k` ячеек памяти, причем все ячейки памяти содержат начальные значения.

База при `k=1` очевидна.  


Пусть теперь `k>1`. По предположению индукции возможно получить конфигурацию, когда `T_1`, `T_2`, …, `T_k` пишут в разные `k` ячеек памяти. Обозначим через `ConfigureThreads()` последовательность операций, приводящую к такой конфигурации. Из `k` потоков в `k` ячеек памяти из `n` возможных существует `C[n,k]` различных отображений. Тогда пусть потоки выполняют `ConfigureThreads() → ConfigureThreads() → … → ConfigureThreads()` всего `C[n,k]+1` раз. По принципу Дирихле найдется такие две `ConfigureThreads()`, которые делают одно и то же соответствие между `T_1`, `T_2`, …, `T_k` и `k` ячейками памяти. Пусть для определенности это первый и последний вызов `ConfigureThreads()`, а запись осуществена в ячейки памяти `X_1`, `X_2`, …, `X_k` соответственно.

Рассмотрим найденное выполение операций `ConfigureThreads() → …`. Остановим потоки в рассмотренной выше конфигурации на первой итерации. Далее запустим `T_[k+1]`. Ясно, что он пишет что-то в какую-то из ячеек `X_[k+1]`, …, `X_n` (по предположению индукции для меньшего `n`). Остановим его перед первой записью в какую-то из этих ячеек. (Возможно, он при этом что-то записал в какие-то из ячеек `X_1`, …, `X_k`!) Далее запускаем наши `ConfigureThreads()` и останавливаем потоки перед своими первыми записями в `X_1`, …, `X_k` на последней итерации. По построению ячейки `X_[k+1]`, …, `X_n` содержат начальные значения. Таким образом, потоки `T_1`, …, `T_k`, `T_[k+1]` остановлены перед своими первыми записями в разные `k+1` ячеек памяти. _Утверждение доказано._

_Значит, искомая конфигурация существует для `k=n`, что и доказывает теорему в общем случае._

#### Замечания

* Каждый метод `lock()` не обязан требовать обращения ко всем `n` ячейкам памяти. Например, в турнирном дереве мьютексов один вызов обращается к `O(log(n))` ячейкам.  
* Для построения противоречия мы не использовали никаких предположений о разрядности ячеек памяти.  
* Доказательство работает даже для случая недетерминированного исполнения.  
* Доказательство не работает, если используется операция `exchange()` или другая RMW-операция: с их помощью можно атомарно менять значение в ячейке памяти и читать старое значение, на основании которого делать выводы о наличии других потоков.  
* Каждый `ConfigureThreads()` для `k` потоков построен с помощью `C[n,k-1]+1` операций `ConfigureThreads()` для `k-1` потоков. Таким образом, для построения «плохого исполнения» в случае `n` потоков используется экспоненциальное число шагов (сумма биномиальных коэффициентов).
* Введение индукции по `n` необязательно. Она требуется только при доказательстве того, что `T_[k+1]` пишет что-то в какую-то из ячеек `X_[k+1]`, …, `X_n`: если нет, то `k+1` поток использует `k` ячеек памяти для взаимного исключения. Так как `k+1⩽n` и доказательство для `n+1` потока, то предположение индукции можно применить. На самом деле индукция не требуется, поскольку достаточно провести рассуждения, аналогичные случаю маленьких `n` (значения в `X_1`, …, `X_k` перезапишут и сотрут следы существования `T_[k+1]`).
